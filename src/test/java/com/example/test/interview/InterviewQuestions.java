package com.example.test.interview;

/**
 * Created by MintQ on 2018/7/10.
 *
 * 《*》三大框架方面问题
 *    1、Spring 事务的隔离性，并说说每个隔离性的区别
 *       事务隔离级别: 1、读未提交 （会出现脏读, 不可重复读。基本不使用）
 *                   2、读已提交 （会出现不可重复读和幻读）               Oracle: 默认使用的是READ COMMITTED
 *                   3、可重复读 （会出现幻读）                         MYSQL: 默认为REPEATABLE_READ级别
 *                   4、可串行化读
 *       ~脏读 : 一个事务读取到另一事务 未提交 的更新数据
 *       ~不可重复读 : 在同一事务中, 多次读取同一数据返回的结果有所不同, 换句话说, 后续读取可以读到另一事务已提交的更新数据.
 *                      相反, "可重复读"在同一事务中多次读取数据时, 能够保证所读数据一样, 也就是后续读取不能读到另一事务已提交的更新数据
 *       ~幻读 : 一个事务读到另一个事务已提交的insert数据
 *
 *    2、Spring事务的传播行为，并说说每个传播行为的区别: @Transactional(propagation=Propagation.REQUIRED)
 *      事物传播行为介绍:
 *          1、REQUIRED：     如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)
 *          2、SUPPORTS：     如果有事务，就用，没有就不用。
 *          3、NOT_SUPPORTED：容器不为这个方法开启事务
 *          4、REQUIRES_NEW： 不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务
 *          5、MANDATORY：    必须在一个已有的事务中执行,否则抛出异常
 *          6、NEVER：        必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)
 *
 *    3、你对spring的理解是什么?
 *           1)开源框架
             2)IoC（控制反转）实现了低耦合，将类的创建和依赖关系写在配置文件里，由配置文件注入，
             3)AOP (面向切面编程) 提高了复用性，将安全，事务等于程序逻辑相对独立的功能抽取出来，利用Spring的配置文件将这些功能插进去，实现了面向切面编程。
 *
 * 《*》负载均衡、集群相关
 *     1、Nginx+Tomcat+Redis实现负载均衡、资源分离、session共享
 *
 *
 * 《*》多线程、并发及线程的基础问题：
 *     1、volatile 能使得一个非原子操作变成原子操作吗？
 *          一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。
 *          为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。（？）
 *     2、volatile 修饰符的有过什么实践？
 *          ~一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，
 *           但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。
 *          ~volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。
 *           意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。
 *     3、volatile 类型变量提供什么保证？ 保证 可见性 和 有序性
 *          ~例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。
 *          ~某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。
 *
 *     4、你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？
 *          ~wait() 方法应该在 循环 调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。
 *     5、什么是线程局部变量？ - ThreadLocal
 *          ~线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持 线程局部变量，是一种 实现线程安全 的方式。
 *          ~但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。
 *     6、Java 中 sleep 方法和 wait 方法的区别？
 *          ~虽然两者都是用来暂停当前运行的线程，但是~ sleep() 实际上只是短暂停顿，因为它 不会释放锁
 *                                             ~而wait() 意味着条件等待，这就是为什么该方法要 释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。
 *     7、什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？
 *          ~不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。
 *
 */
public class InterviewQuestions {

}
