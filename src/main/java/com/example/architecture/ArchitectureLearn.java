package com.example.architecture;

/**
 * Created by MintQ on 2018/7/11.   分布式、高并发、微服务架构总结
 *
 * 《*》设计思想总结：
 *      1、我个人认为，在设计产品或者技术架构上，首先应该遵循 化繁为简 的原则，一定要避免过度设计，这个我们早期确实也踩过不少的坑；
 *         再者就是要一起从业务场景出发，做好需求分析，了解用户的核心痛点才能做到设计直击痛点、方便用户，因为平台的发展离不开业务的滋养，也正是业务场景的不断变化才带来了平台的不断进步；
 *         最后，平台的稳定 是一切的基础，一切性能优化都需要找到那个平衡点。
 *      2、抽象就是从变化的东西中找到不变的东西。
 *      3、微服务 ：是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。
 *      4、分布式：分布式是一种 思想，是将原本的 单节点应用 分布到 不同的服务器节点，以求获得更大的运算能力和更高的性能。
 *
 * 《可能是讲分布式系统最到位的一篇文章》：
 *   1、 分布式系统的核心思想 -  “分治”。  因此从“分治”这个本质上来看，服务化的确是分布式系统，但分布式系统不仅仅停留在那些服务化的模式上。
 *   2、“分布式系统”是各种中间件吗？ -
 *   3、所以，我们可以这么理解，涉及 多个进程协作 才能提供一个完整功能的系统就是“分布式系统”。
 *   4、总结：
 *
 * 《*》如何设计出高可用的分布式架构？ 在分布式架构中，SOA 和微服务架构是最常见的两种分布式架构，而且目前 服务网格 的概念也越来越火了，我们就先从这些常见的架构开始。
 *     一、SOA 架构解析：SOA 全称是：Service Oriented Architecture，中文释义为 “面向服务的架构”。
 *          ~SOA 所要解决的核心问题是：
 *              1、系统间的集成：
 *              2、系统的服务化：
 *              3、业务的服务化：
 *          ~SOA 强调 用统一的协议进行服务间的通信，服务间运行在彼此独立的硬件平台但是需通过统一的协议接口相互协作，也即将应用系统服务化。
 *          ~举个易懂的例子：单体服务如果相当于一个快餐店，所有的服务员职责都是一样的，又要负责收银结算，又要负责做汉堡，又要负责端盘子，又要负责打扫，服务员之间不需要有交流，用户来了后，服务员从前到后负责到底。
 *              SOA 相当于让服务员有职责分工，收银员负责收银，厨师负责做汉堡，保洁阿姨负责打扫等，所有服务员需要用同一种语言交流，方便工作协调。
 *     二、微服务（Microservices）架构解析：
 *          ～微服务 - 是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。
 *          ~微服务架构和 SOA 架构非常类似，微服务是 SOA 的升华，只不过微服务架构强调的是“业务需要彻底的组件化及服务化”，原单个业务系统会被拆分为多个可以独立开发、设计、部署运行的小应用。
 *          ~微服务的特征：1、通过服务实现组件化
 *                       2、按业务能力来划分服务和开发团队
 *                       3、去中心化
 *                       4、基础设施自动化(DevOps、自动化部署)
 *          ~SOA 注重的是 系统集成，而微服务关注的是 完全分离。
 *
 *     三、服务网格（Service Mesh）架构解析：
 *          ~2017 年年底，非侵入式的 Service Mesh 技术慢慢走向了成熟。Service Mesh ，中文释义“服务网格”，作为服务间通信的基础设施层在系统中存在。
 *          ~如果要用一句话来解释什么叫 Service Mesh，我们可以将它比作是应用程序或者说微服务间的 TCP/IP，负责服务间的 网络调用、熔断、限流和监控。
 *          ~服务网格的特征：1、应用程序间通讯的中间层
 *                        2、轻量级网络代理
 *                        3、应用程序无感知
 *                        4、解耦应用程序的重试/超时、监控、追踪和服务发现
 *     四、分布式架构的基本理论
 *          ~在说 CAP、BASE 理论之前，我们先要了解下分布式一致性的问题。对于不同业务的服务，我们对数据一致性的要求是不一样的。
 *          1、关于分布式一致性问题：
 *              所谓分布式一致性的问题，就是指在分布式环境中引入 数据复制机制 后，不同数据节点之间可能会出现的、且无法依靠计算机应用程序自身解决的数据不一致的情况。
 *              简单来说， 数据一致性就是指在对一个副本数据进行变更的时候，必须确保也能够更新其他的副本，否则不同副本之间的数据将出现不一致。
 *              故我们没有办法找到一种既能够满足数据一致性、 又不影响系统性能的方案，所以就诞生了一个一致性的级别：
 *                  1、强一致性：这种一致性级别是最符合用户直觉的，它要求系统写入的是什么，读出来的也要是什么，用户体验好，但实现起来往往对系统的性能影响较大。
 *                  2、弱一致性：这种一致性级别约束了系统在写入成功后， 不保证立即可以读到写入的值，也不保证多久之后数据能够达到一致，但会尽可能地保证到某个时间级别(如秒级别)后，数据能够达到一致状态。
 *                  3、最终一致性：最终一致性其实是弱一致性的一个特例，系统会保证在一定时间内，能够达到数据一致的状态。
 *                                这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上用的比较多的一致性模型。
 *          2、CAP 理论：- CAP 理论是一个 经典 的分布式系统理论。 CAP 理论在互联网界有着广泛的知名度，也被称为“帽子理论”，它是由 Eric Brewer 教授在 2000 年举行的 ACM 研讨会提出的一个著名猜想。
 *                      它告诉我们：一个分布式系统不可能同时满足一致性(C：Consistency)、可用性(A：Availability)及分区容错性(P：Partition tolerance) 这三个基本要求，最多只能同时满足其中两项。
 *                          <1>一致性：所有节点上的数据时刻保持同步。
 *                          <2>可用性：每个请求都能接收一个响应，无论响应成功或失败。
 *                          <3>分区容错：系统应该持续提供服务，即使系统内部(某个节点分区)有消息丢失。
 *                      ~CAP 并不是一个普适性原理和指导思想，它仅适用于原子读写的 NoSQL 场景中，并 不适用于数据库系统。
 *          3、BASE 理论：- eBay 尝试了另外一条完全不同的路，放宽了数据库事务的 ACID 要求，提出了一套名为 BASE 的新准则。
 *                        BASE 全称为 Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）三个短语的缩写。相对于 CAP 来说，它大大降低了我们对系统的要求。
 *                          <1>Basically Available(基本可用) - 表示在分布式系统出现不可预知的故障时，允许瞬时部分可用性：
 *                          <2>Soft-state(软状态) - 表示系统中的数据存在中间状态，并且这个中间状态的存在不会影响系统的整体可用性，也就是表示系统允许在不同节点的数据副本之间进行数据同步过程中存在延时。
 *                          <3>Eventually consistent(数据的最终一致性) -
 *                              表示的是所有数据副本在一段时间的同步后最终都能达到一个一致的状态，因此最终一致性的本质是要保证数据最终达到一致，而不需要实时保证系统数据的强一致。
 *                          ~BASE 理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。
 *     五、分布式架构下的高可用设计
 *          1、避免单点故障：~负载均衡技术(failover/选址/硬件负载/ 软件负载/去中心化的软件负载(gossip(redis- cluster)))
 *                        ~热备(Linux HA)
 *                        ~多机房(同城灾备、异地灾备)
 *          2、应用的高可用性：
 *          3、分布式架构下的可伸缩设计：~垂直伸缩
 *                                   ~提升硬件能力
 *                                   ~水平伸缩
 *                                   ~增加服务器
 *          4、加速静态内容访问速度的 CDN : CDN 全称是 Content Delivery Network，中文释义是内容分发网络。
 *              ~CDN 的作用是把 用户需要的内容 分发到 离用户最近的地方 进行响应，这样用户能够快速获取所需要的内容。
 *              ~CDN 本质上就是一种 网络缓存技术，能够把一些相对稳定的资源放到距离最终用户较近的地方，一方面可以节省整个广域网的 带宽消耗，另外一方面也可以提升用户的访问速度、改善用户体验。
 *              ~现实系统中我们一般会把 静态的文件(图片、脚本、静态页面等)放到 CDN 中：
 *          5、什么情况下用 CDN？- 最适合的是那些 不会经常变化 的内容，比如图片，JS 文件，CSS 文件。图片文件包括程序模板中 CSS 文件中用到的背景图片，还有就是作为网站内容组成部分的那些图片等等。
 *
 *          6、灰度发布：我们的应用即使经过了测试部门的测试，也仍然很难全面覆盖用户的使用场景。
 *              ~为了保证万无一失，我们在进行发布的时候一般都会采用灰度发布，也就是会对新应用进行分批发布，逐步扩大新应用在整个及集群中的比例直到最后全部完成。灰度发布是说针对新应用在用户体验方面完全无感知。
 *              ~简单的说，就是一套 A/B Test 系统
 *
 *《大型互联网公司微服务架构进化史》-
 *  一、微服务架构介绍
 *     - 微服务 - 是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。
 *
 * 《*》分布式与集群的区别是什么？
 *      1、单机结构：- 普通的软件是运行在一台物理机器上的，一个系统业务量很小的时候，可以将所有的代码都放在一个项目中，然后部署在一台服务器上，这台服务器提供整个项目所有的服务。
 *                      单机结构的啥缺点显而易见，因为它的处理能力是有限的，当业务增长到一定程度的时候，单机的硬件资源将无法满足。
 *      2、集群模式 - 此时便出现了集群模式，单机处理到达瓶颈的时候，你就把单机复制几份，这样就构成了一个“集群”。集群中每台服务器就叫做这个集群的一个“节点”，所有节点构成了一个集群。
 *                  每个节点都提供相同的服务，那么这样系统的处理能力就相当于提升了好几倍。
 *      3、分布式结构 - 就是将一个完整的系统，按照业务功能，把一个服务系统拆分成一个个独立的子系统，在分布式结构中，每个子系统就被称为“服务”。
 *                      这些子系统能够独立运行在web容器中，它们之间通过RPC方式通信。
 *
 *      从工作形式来说：
 *          分布式 - 是将一个业务分拆为多个子业务，部署在不同的服务器上。
 *                - 分布式是以 缩短单个任务的执行时间 来提升效率的，任务具有 差异性。
 *          集群 - 是将多台服务器集中在一起，实现同一业务。
 *              - 集群是以 提高单位时间内执行的任务数 来提升效率的，任务具有 同一性。
 *
 *
 *《*》大型分布式系统的优化解决方案 - 根据网站分层架构,性能优化可分为：1、web前端性能优化 2、应用服务器性能优化 3、存储服务器性能优化（数据库等）。
 *  1、web前端性能优化 -
 *      1、减少http请求数量
 *      2、是否适用压缩 （gzip压缩）
 *      3、css放页面首部加载，js放页面底部加载。
 *      4、是否适用CDN网络。
 *  2、应用服务器性能优化
 *      1、单例模式
 *      2、Future模式（异步模式）
 *      3、线程池
 *      4、NIO (选择就绪) - 同步非阻塞IO(Selector、Buffer、Channel) - 提高程序的并发吞吐能力，降低系统的开销。
 *      5、降低锁竞争 - 锁的竞争会使得更多的线程等待，本来并行的操作变成串行，并且会导致上下文频繁地切换。因此，减少锁的竞争能够提高程序的性能。
 *          1、尽可能地缩短持有锁的时间。
 *          2、减少请求 同一个锁的 频率。例子：ConcurrentHashMap - 分段锁
 *          3、放弃使用独占锁，采用乐观锁机制。- 原子变量、读写锁 - CAS机制
 *  3、存储服务器性能优化（数据库等）
 *      1、合理使用索引。- 最左匹配原则、
 *      2、反范式设计
 *      3、
 *
 * 注意：1、LVS是Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。本项目在1998年5月由章文嵩博士成立，是中国国内最早出现的自由软件项目之一。
 *      2、一般在后台N个服务和UI之间一般会一个代理或者叫API Gateway，他的作用包括：① 提供统一服务入口，让微服务对前台透明
 *                                                                         ② 聚合后台的服务，节省流量，提升性能
 *                                                                         ③ 提供安全，过滤，流控等API管理功能
 *
 */
public class ArchitectureLearn {

}
