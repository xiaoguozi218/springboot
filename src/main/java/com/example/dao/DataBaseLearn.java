package com.example.dao;

/**
 * Created by gsh on 2018/7/19.
 *
 *《MySQL扩展具体的实现方式》：关于数据库的扩展主要包括：1、业务拆分 2、主从复制 3、数据库分库与分表。
 * 一、业务拆分 - 由原来的单体应用根据业务进行拆分，进行微服务改造，每一个模块都使用单独的数据库来进行存储，不同的业务访问不同的数据库，系统的吞吐量自然就提高了。
 * 二、主从复制 -
 *    - 主要讲述了MySQL主从复制的原理：数据复制的实际就是Slave从Master获取Binary log文件，然后在 本地镜像 的执行日志中记录的操作。
 *                                 由于主从复制的过程是异步的，因此Slave和Master之间的数据 有可能存在延迟 的现象，此时只能保证数据 最终的一致性。
 * 三、数据库分库与分表
 *  1、分表实现策略 - 关键字：用户ID、表容量
 *     - 对于大部分数据库的设计和业务的操作基本都与用户的ID相关，因此使用用户ID是最常用的分表的路由策略。用户的ID可以作为贯穿整个系统用的重要字段。
 *       因此，使用用户的ID我们不仅可以方便我们的查询，还可以将数据平均的分配到不同的数据库中。
 *    - 接着上述电商平台假设，订单表order存放用户的订单数据 -
 *      当数据比较大的时候，对数据进行分表操作，首先要确定需要将数据平均分配到多少张表中，也就是：表容量。
 *      这里假设有100张表进行存储，则我们在进行存储数据的时候，首先对用户ID进行取模操作，根据 user_id%100 获取对应的表进行存储查询操作，
 * 注意：在实际的开发中，如果你使用MyBatis做持久层的话，MyBatis已经提供了很好得支持数据库分表的功能，例如上述sql用MyBatis实现的话应该是：
 *
 *  2、分库实现策略 - 用户ID、库容量
 *     - 数据库分表能够解决单表数据量很大的时候数据查询的效率问题，但是无法给数据库的并发操作带来效率上的提高，
 *       因为分表的实质还是在一个数据库上进行的操作，很容易受数据库IO性能的限制。
 *     - 分库策略与分表策略的实现很相似，最简单的都是可以通过 取模的方式 进行路由。
 *
 * 四、分库与分表实现策略
 *      - 上述的配置中，数据库分表可以解决 单表海量数据的查询性能问题，分库可以解决 单台数据库的并发访问压力问题。
 *      - 有时候，我们需要同时考虑这两个问题，因此，我们既需要对单表进行分表操作，还需要进行分库操作，以便同时扩展系统的并发处理能力和提升单表的查询性能，就是我们使用到的分库分表。
 *      - 分库分表的策略相对于前边两种复杂一些，一种常见的路由策略如下：
 *          １、中间变量　＝ user_id%（库数量*每个库的表数量）;
 *          ２、库序号　＝　取整（中间变量／每个库的表数量）; - 取整
 *          ３、表序号　＝　中间变量％每个库的表数量;       - 取模
 *       例如：数据库有256 个，每一个库中有1024个数据表，用户的user_id＝262145，按照上述的路由策略，可得：这样的话，对于user_id＝262145，将被路由到第０个数据库的第１个表中。
 *          １、中间变量　＝ 262145%（256*1024）= 1;
 *          ２、库序号　＝　取整（1／1024）= 0;
 *          ３、表序号　＝　1％1024 = 1;
 *
 *
 * 注意：
 *  - 最后需要指出的是，分库分表目前有很多的中间件可供选择，最常见的是使用淘宝的中间件Cobar。  还有MyCat
 *  - 上述的分库和分表操作，查询性能和并发能力都得到了提高，但是还有一些需要注意的就是，例如：1、原本跨表的事物变成了分布式事物；2、关联查询麻烦 3、数据迁移也变得麻烦了
 *  -
 *
 *
 *《数据库索引为什么使用B树？》
 *  1、名次解释：- B tree： 二叉树（Binary tree），每个节点只能存储一个数。
 *             - B-tree：B树（B-Tree，并不是B“减”树，横杠为连接符，容易被误导）B树属于多叉树又名 平衡多路查找树。每个节点可以多个数（由磁盘大小决定）。
 *             - B+tree 和 B*tree 都是 B-tree的变种
 *  2、索引为什么是用B树呢？
 *    一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，
 *    所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要 尽量减少查找过程中磁盘I/O的存取次数。
 *    而B-/+/*Tree，经过改进可以有效的利用系统对磁盘的 块读取特性，在读取相同磁盘块的同时，尽可能多的加载索引数据，来提高索引命中效率，从而达到减少磁盘IO的读取次数。
 *    2.1 - B-tree
 *        - B-tree 利用了 磁盘块 的特性进行构建的树。每个磁盘块一个节点，每个节点包含了很关键字。把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。
 *        - B-tree 巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页（每页为4K），这样每个节点只需要一次I/O就可以完全载入。B-tree 的数据可以存在任何节点中。
 *    2.2 - B+tree - B+tree 是 B-tree 的变种，数据只能存储在 叶子节点。
 *        - B+tree 是 B-tree 的变种，B+tree 数据只存储在叶子节点中。这样在B树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快，
 *          所有指关键字指针都存在叶子节点，所以每次查找的次数都相同所以查询速度更稳定;
 *    2.3 - B*tree
 *        - B*tree 每个磁盘块中又添加了对下一个磁盘块的引用。这样可以在当前磁盘块满时，不用扩容直接存储到下一个临近磁盘块中。
 *          当两个邻近的磁盘块都满时，这两个磁盘块各分出1/3的数据重新分配一个磁盘块，这样这三个磁盘块的数据都为2/3。
 *        - B*tree在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；
 *
 *《MySQL的btree索引和hash索引的区别》：
 *      - 索引是帮助mysql获取数据的数据结构。最常见的索引是Btree索引和Hash索引。
 *      - 不同的引擎对于索引有不同的支持：Innodb和MyISAM默认的索引是Btree索引； 而Mermory默认的索引是Hash索引。
 *  1、hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到支节点，最后才能访问到叶子节点这样多次的IO访问，
 *     所以 Hash 索引的查询效率要远高于 B-Tree 索引。
 *  2、可能很多人又有疑问了，既然 Hash 索引的效率要比 B-Tree 高很多，为什么大家不都用 Hash 索引而还要使用 B-Tree 索引呢？
 *    任何事物都是有两面性的，Hash 索引也一样，虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。
 *  3、Hash索引的缺点：
 *      1、因为Hash索引比较的是经过Hash计算的值，所以只能进行等式比较，不能用于范围查询
 *      2、每次都要全表扫描
 *      3、由于哈希值是按照顺序排列的，但是哈希值映射的真正数据在哈希表中就不一定按照顺序排列，所以无法利用Hash索引来加速任何 排序操作
 *      4、不能用部分索引键来搜索，因为组合索引在计算哈希值的时候是一起计算的。
 *      5、Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。
 *
 *  4、Btree索引：至于Btree索引，它是以B+树为存储结构实现的。 - 但是Btree索引的存储结构在 Innodb 和 MyISAM 中有很大区别。
 *      - MyISAM：在 MyISAM中 数据文件和索引文件 是分开的。- 因此MyISAM的索引方式也称为 非聚集，Innodb的索引方式成为 聚集索引。
 *      - Innodb：Innodb的 索引文件就是数据文件
 *
 *
 */
public class DataBaseLearn {

}
