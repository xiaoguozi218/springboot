package com.example.concurrent.thread;

/**
 * Created by MintQ on 2018/6/15.
 *
 *  Java的线程分为两种：User Thread(用户线程):
 *                    DaemonThread(守护线程): 只要当前JVM实例中尚存任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束是，守护线程随着JVM一同结束工作，Daemon作用是为其他线程提供便利服务，守护线程最典型的应用就是GC(垃圾回收器)，他就是一个很称职的守护者。
 *     这里有几点需要注意：(1) thread.setDaemon(true)必须在thread.start()之前设置，否则会抛出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。
 *                      (2) 在Daemon线程中产生的新线程也是Daemon的。
 *                      (3) 不要认为所有的应用都可以分配给Daemon来进行服务，比如读写操作或者计算逻辑。写java多线程程序时，一般比较喜欢用java自带的多线程框架，比如ExecutorService，但是java的线程池会将守护线程转换为用户线程，所以如果要使用后台线程就不能用java的线程池。
 *
 *
 *
 *
 *  Java多线程的join和interrupt方法：
 *      Java的join()官方的解释: Waits for this thread to die.   等待当前线程直到当前线程结束
 *      假设现在有A、B，线程A在线程B内调用A.join()，那么线程B会被挂起，直到A线程完成后才恢复。
 *
 *
 *
 *
 *
 *
 *
 *
 *  三、安全发布对象
 *
 *  发布对象：使一个对象能够被当前范围之外代码所使用。
    对象逸出：一种错误的发布。当一个对象还没有构造完成，就能被其它线程所见。
 *
 *  安全发布对象：
     在静态初始化函数中初始化一个对象的引用；
     将对象的引用保存到volatile类型域或者AtomicReference对象中；
     对象引用保存到某个正确构造对象final类型域中；
     将对象的引用保存到一个由锁保护的域中。

     对此，单例模式是个很好的学习例子：

 *
 *
 *
 *
 *
 *
 *  六、线程与线程池
 *      线程：程序独立执行的最小单位（基本单位），可以理解成进程中独立运行的子任务。
        进程：一旦程序运行起来就变成了操作系统当中的一个进程。
 *  线程的创建:  1、继承Thread类       ：局限性：Java单继承，不易于扩展。
 *             2、实现Runnabl接口    ：
 *             3、实现Callable      ：运行Callable任务可以拿到一个Future对象，进行异步计算。
 *             4、线程池  : newCachedThreadPool     创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。潜在问题线程如果创建过多可能内存溢出。
 *                         newFixedThreadPool      创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
 *                         newScheduledThreadPool   创建一个定长线程池，支持定时及周期性任务执行。
 *                         newSingleThreadExecutor  创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO、LIFO、优先级）执行。
 *
 *
 *  为了保证共享数据的完整性，Java中引入了互斥锁的概念，即每个对象对应一个“互斥锁”的标记（monitor），用来保证任何时刻只能有一个线程访问该对象。利用Java中每个对象都拥有唯一的一个监视锁（monitor），当线程拥有这个标记时才会允许访问这个资源，而未拿到标记则进入阻塞，进入锁池。每个对象都有自己的一个锁池的空间，用于存放等待线程。由系统决定哪个线程拿到锁标记并运行。
 *
 *
        方法：currentThread():当前调用线程的相关信息；
             isAlive():判断当前线程是否处于活动状态；
             getId():线程的唯一标识；
             interrupted():测试当前线程是否已经中断；注：线程终端状态由该方法清除，意味着连续两次执行此方法，第二次将返回false。
             isInterrupted():测试线程是否已经中断； 注：不清楚状态标志。
             run(): 线程执行的具体方法，执行完成的会进入消亡状态；
             start():使县城出局就绪状态，等待调用线程的对象执行run()方法；
             sleep():让当前线程放弃CPU时间片直接返回就绪状态。
             yield():让当前线程放弃CPU时间片直接返回就绪状态。但放弃的时间片不确定，可能刚刚放弃，便立即获取。
 *
 *      线程通信： join(): 让当前线程邀请调用方法的线程优先执行，在被邀请的线程执行结束之前，邀请别人的线程不再执行，处于阻塞状态，直到被邀请的线程执行结束之后，进入就绪状态；
                 interrupt(): 中断、打断线程的阻塞状态。直接让阻塞状态的线程返回就绪，由sleep()、join()导致的阻塞立刻解除；
                 wait():使当前执行代码的线程放弃monitor并进入等待状态，直到接收到通知或被中断为止（notify）。即此时线程将释放自己的所有锁标记和CPU占用，同时进入这个对象的等待池（阻塞状态）。只能在同步代码块中调用（synchronized）；
                 notify():在等待池中随机唤醒一个线程，放入锁池，对象处于等待状态，直到获取对象的锁标记为止。 只能在同步代码块中调用（synchronized）。

 *
 *
 *
 *
 */
public class ThreadLearn {



}
