package com.example.concurrent;

/**
 * Created by MintQ on 2018/7/10.
 *
 * 《*》"分布式事务"解决方案汇总 -- 2PC/TCC/事务消息/1PC
 *      1、2PC ：   说到分布式事务，就会提到2pc。
 *          ~2PC简介：2pc涉及到2个阶段，3个操作： prepare/commit/rollback
 *                  阶段1：“准备提交”。事务协调者向所有参与者发起prepare，所有参与者回答yes/no。
 *                  阶段2：“正式提交”。如果所有参与者都回答yes，则向所有参与者发起commit；否则，向所有参与者发起rollback。
 *                      因此，要实现2pc，所有参与者，都得实现3个接口：prepare/commit/rollback。
 *          ~2PC的实现：关于2pc，对应的实现层面，也就是XA协议。有一个Atomikos开源库，也实现了这个协议。有兴趣的可以去看一下如何使用。
 *          ~2PC的问题：（1）阶段2，事务协调者挂了，则所有参与者接受不到commit/rollback指令，将处于“悬而不决”状态
 *                     （2）阶段2，其中一个参与者超时或者出错，那其他参与者，是commit，还是rollback呢？ 也不能确定
 *                    为了解决2pc的问题，又引入3pc。3pc有类似的挂了如何解决的问题，因此还是没能彻底解决问题，此处就不详述了。
 *      2、TCC ： 为了解决SOA系统中的分布式事务问题，支付宝提出了 TCC。2PC通常都是在跨库的DB层面，而TCC本质就是一个应用层面的2PC。
 *          ~同样，TCC中，每个参与者需要3个操作：Try/Confirm/Cancel，也是2个阶段。
 *                  阶段1：”资源预留/资源检查“，也就是事务协调者调用所有参与者的Try操作
 *                  阶段2：“一起提交”。如果所有的Try成功，一起执行Confirm。否则，所有的执行Cancel.
 *          ~TCC是如何解决2PC的问题呢？
 *              关键：Try阶段成功之后，Confirm如果失败(不管是协调者挂了，还是某个参与者超时），不断重试！！
 *              同样，Cancel失败了，也是不断重试。这就要求Confirm/Cancel都必须是幂等操作。
 *              ~下面以1个转账case为例，来说明TCC的过程：
 *                  有3个账号A, B, C，通过SOA提供的转账服务操作。A, B同时分别要向C转30, 50元，最后C的账号+80，A, B各减30, 50。
 *                  阶段1：A账号锁定30，B账号锁定50，检查C账号的合法性（比如C账号是否违法被冻结，C账号是否已注销。。。）。 所以，对应的“扣钱”的Try操作就是”锁定”，对应的“加钱”的Try操作就是检查账号合法性
 *                  阶段2：A, B, C都Try成功，执行Confirm。即A, B减钱，C加钱。如果任意一个失败，不断重试！
 *                  从上面的案例可以看出，Try操作主要是为了“保证业务操作的前置条件都得到满足”，然后在Confirm阶段，因为前置条件都满足了，所以可以不断重试保证成功。
 *
 *      3、事务消息 – 最终一致性
 *
 *      4、1PC – Saga – 事务补偿
 *          ~我们知道，在TCC里面，有2个阶段。其中第1个阶段是“锁定资源”，目的是为了保证第2个阶段的提交在业务上不会失败。
 *          ~而1pc，就是舍弃掉第1个阶段，不做资源锁定，直接进行第2个阶段的提交！如果业务的特性可以允许不需要锁定资源，那就可以省去第1个阶段，直接做第2个阶段。
 *          ~如果第2个阶段失败呢，有2种策略：策略1，同TCC一样，也是不断重试commit，硬着头皮上；策略2，回滚，也就是事务补偿，做之前操作的反操作。
 *
 *
 * 《*》微服务架构如何解决跨库问题的思路与方案？
 *      在数据分布在不同的数据库服务器的带来良好性能的同时，新的问题也随之而来，比如说数据一致性的保证，性能监控，数据存取复杂等，而较为突出的就是数据跨库问题！
 *          数据分布在不同的节点上，导致原来的连接查询需要跨库，字段的主键难以保证唯一，跨库的事务处理复杂，下面逐一解决:
 *      1、连接查询(join)问题: 因为库表分布在不同的机器上，连接查询失效。
 *         解决办法:①，代码解决:根据某个字段进行hash的方式进行分库分表，保证落在一个库中的类似表中(比如aa_00.t_user_0000和aa_00.t_member_0000)，然后基于这样的规则在代码中进行连接查询语句书写！
 *                 ②，同步:将常用的字段同步到一个库中进行联合查询！
 *                 ③，冗余:在一个库中冗余更多的连接查询需要的字段，保证全部数据都能查询到！
 *      2、唯一主键: 如果使用传统的自增等方式，多库中的主键id势必重复，所以需要对唯一性加以控制！
 *          解决方法:UUID(根据机器ID，时间等)，redis(单线程保证不重复)，snowflake算法（雪花）！
 *
 *      3、分布式事务:
 *          ~TCC:try控制业务代码流程，Confirm确认事务的正确性，cancel取消失败的事务！
 *
 *          ~基于消息系统的一致性方案:单节点事务完成后，通过发送消息保证事务提交，如果失败可通过重试，任务补偿等方式保证数据一致性！
 *
 *《微服务架构的数据一致性问题》：
 *  1、微服务架构的数据一致性问题 - 以电商平台为例，当用户下单并支付后，系统需要修改订单的状态并且增加用户积分。由于系统采用的是微服务架构，分离出了支付服务、订单服务和积分服务，每个服务都有独立数据库做数据存储。
 *                              当用户支付成功后，无论是修改订单状态失败还是增加积分失败，都会造成数据的不一致。
 *      - BASE 模型与 ACID 不同，满足 CAP 理论，通过 牺牲强一致性来保证系统可用性。由于牺牲了强一致性，系统在处理请求的过程中，数据可以存在短时的不一致。
 *          系统在处理业务时，记录每一步的临时状态。当出现异常时，根据状态判断是否继续处理请求或者退回原始状态，从而达到数据的最终一致。
 *          例如，在上面的案例中，支付成功，订单也成功，但增加积分失败，此时，不应回滚支付和订单，而应通过一些 补偿方法 来让积分得以正确地增加。后面会讲到具体的实现方法。
 *
 *
 */
public class DistributedTransaction {
}
