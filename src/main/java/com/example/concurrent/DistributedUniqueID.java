package com.example.concurrent;

/**
 * @Auther: gsh
 * @Date: 2018/8/1 13:57
 * @Description: 高并发分布式系统中生成全局唯一ID汇总
 *
 *
 * 一、twitter - twitter在把存储系统从MySQL迁移到Cassandra的过程中由于Cassandra没有顺序ID生成机制，于是自己开发了一套全局唯一ID生成服务：Snowflake。- 雪花算法
 *          1、1位不用
 *          2、41位的时间序列（精确到毫秒，41位的长度可以使用69年）
 *          3、10位的机器标识（10位的长度最多支持部署1024个节点）
 *          4、12位的计数顺序号（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号） 最高位是符号位，始终为0。
 *      - 优点：高性能，低延迟；独立的应用；按时间有序。
 *      - 缺点：需要独立的开发和部署。
 *
 * 二、来自Flicker的解决方案 -
 *      - 因为MySQL本身支持auto_increment操作，很自然地，我们会想到借助这个特性来实现这个功能。
 *      - Flicker在解决全局ID生成方案里就采用了MySQL自增长ID的机制（auto_increment + replace into + MyISAM）。一个生成64位ID方案具体就是这样的：
 *          - 先创建单独的数据库(eg:ticket)，然后创建一个表：
 *          - 当我们插入记录后，执行SELECT * from Tickets64，查询结果就是这样的：
 *          - 在我们的应用端需要做下面这两个操作，在一个事务会话里提交：
 *          - 这样我们就能拿到不断增长且不重复的ID了。
 *          - 到上面为止，我们只是在单台数据库上生成ID，从高可用角度考虑，接下来就要解决单点故障问题：
 *              Flicker启用了两台数据库服务器来生成ID，通过区分auto_increment的起始值和步长来生成奇偶数的ID。最后，在客户端只需要通过轮询方式取ID就可以了。
 *      - 优点：充分借助数据库的自增ID机制，提供高可靠性，生成的ID有序。
 *      - 缺点：占用两个独立的MySQL实例，有些浪费资源，成本较高。
 *
 * 三、UUID - UUID生成的是length=32的16进制格式的字符串，如果回退为byte数组共16个byte元素，即UUID是一个128bit长的数字，一般用16进制表示。
 *      - 算法的核心思想是结合机器的网卡、当地时间、一个随即数来生成UUID。
 *      - 从理论上讲，如果一台机器每秒产生10000000个GUID，则可以保证（概率意义上）3240年不重复。
 *      - 优点：（1）本地生成ID，不需要进行远程调用，时延低
 *             （2）扩展性好，基本可以认为没有性能上限
 *      - 缺点：（1）无法保证趋势递增
 *             （2）uuid过长，往往用字符串表示，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）
 *
 * 四、基于redis的分布式ID生成器
 *
 * 五、MongoDB文档（Document）全局唯一ID
 */
public class DistributedUniqueID {

}
