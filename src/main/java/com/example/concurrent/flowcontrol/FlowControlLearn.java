package com.example.concurrent.flowcontrol;

/**
 * Created by MintQ on 2018/7/9.
 *
 * 对高并发流量控制的一点思考:
 *  一、应对大流量的一些思路：
 *     1、首先，我们来说一下什么是大流量？  大流量，我们很可能会冒出：TPS（每秒事务量），QPS（每秒请求量），1W+，5W+，10W+，100W+...。
 *                                      其实并没有一个绝对的数字，如果这个量造成了 系统的压力，影响了 系统的性能，那么这个量就可以称之为大流量了。
 *     2、其次，应对大流量的一些常见手段是什么？
 *          ~缓存：说白了，就是让数据尽早进入缓存，离程序近一点，不要大量频繁的访问DB。
 *          ~降级：如果不是核心链路，那么就把这个服务降级掉。打个比喻，现在的APP都讲究千人千面，拿到数据后，做个性化排序展示，如果在大流量下，这个排序就可以降级掉！
 *          ~限流：大家都知道，北京地铁早高峰，地铁站都会做一件事情，就是限流了！想法很直接，就是想在一定时间内把请求限制在一定范围内，保证系统不被冲垮，同时尽可能提升系统的吞吐量。
 *      注意到，有些时候，缓存和降级是解决不了问题的，比如，电商的双十一，用户的购买，下单等行为，是涉及到大量写操作，而且是核心链路，无法降级的，这个时候，限流就比较重要了。 那么接下来，我们重点说一下，限流。
 *
 *     3、限流的常用方式： 计数器、滑动窗口、漏桶、令牌桶。
 *        1、计数器
 *           计数器是一种比较简单的限流算法，用途比较广泛，在接口层面，很多地方使用这种方式限流。在一段时间内，进行计数，与阀值进行比较，到了时间临界点，将计数器清0。
 *
 *        2、滑动窗口
 *           由于计数器存在临界点缺陷，后来出现了滑动窗口算法来解决。
 *           滑动窗口的意思是说把固定时间片，进行划分，并且随着时间的流逝，进行移动，这样就巧妙的避开了计数器的临界点问题。也就是说这些固定数量的可以移动的格子，将会进行计数判断阀值，因此格子的数量影响着滑动窗口算法的精度。
 *        3、漏桶
 *           虽然滑动窗口有效避免了时间临界点的问题，但是依然有时间片的概念，而漏桶算法在这方面比滑动窗口而言，更加先进。
 *           有一个固定的桶，进水的速率是不确定的，但是出水的速率是恒定的，当水满的时候是会溢出的。
 *        4、令牌桶
 *           注意到，漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。为了解决这个问题，令牌桶进行了算法改进。
 *           生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。（有一点生产令牌，消费令牌的意味）
 *           不论是对于令牌桶拿不到令牌被拒绝，还是漏桶的水满了溢出，都是为了保证大部分流量的正常使用，而牺牲掉了少部分流量，这是合理的，如果因为极少部分流量需要保证的话，那么就可能导致系统达到极限而挂掉，得不偿失。
 *
 *      4、限流神器：Guava RateLimiter
 *          Guava不仅仅在集合、缓存、异步回调等方面功能强大（可以参考博主的《使用Google Guava快乐编程》），而且还给我们封装好了限流的API！
 *          Guava RateLimiter基于令牌桶算法，我们只需要告诉RateLimiter系统限制的QPS是多少，那么RateLimiter将以这个速度往桶里面放入令牌，然后请求的时候，通过tryAcquire()方法向RateLimiter获取许可（令牌）。
 *
 *
 *  二、分布式场景下的限流：
 *      上面所说的限流的一些方式，都是针对单机而言的，其实大部分的场景，单机的限流已经足够了。分布式下限流的手段常常需要多种技术相结合，比如Nginx+Lua，Redis+Lua等去做。
 *      本文主要讨论的是单机的限流，这里就不在详细介绍分布式场景下的限流了。
 *      一句话，让系统的流量，先到队列中排队、限流，不要让流量直接打到系统上。
 *
 */
public class FlowControlLearn {

}
