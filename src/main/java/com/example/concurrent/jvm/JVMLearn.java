package com.example.concurrent.jvm;

/**
 * Created by MintQ on 2018/6/28.
 *
 *  深入浅出JVM的锁优化案例
 *
 *  《*》锁优化 ：1、适应性自旋（Adaptive Spinning）： 线程阻塞的时候，让等待的线程不放弃cpu执行时间，而是执行一个自旋(一般是空循环)，这叫做自旋锁。
 *                  自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果 锁被占用的时间很短，自旋等待的效果就非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，带来性能上的浪费。
 *                  因此，自旋等待的时间必须要有 一定的限度。如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是 10 次，用户可以使用参数-XX：PreBlockSpin来更改。
 *                  JDK1.6引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。比如前一次自旋了3次就获得了一个锁，那么下一次虚拟机会允许他自旋更多次来获得这个锁。如果一个锁很少能通过自旋成功获得，那么之后再遇到这个情况就会省略自旋过程了。
 *              2、锁消除（Lock Elimination）    ：
 *                  虚拟机 即时编译器 在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。一般根据 逃逸分析 的数据支持来作为判定依据。
 *              3、锁粗化（Lock Coarsening）     ：
 *                  原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。
 *                  但如果一系列操作频繁对同一个对象加锁解锁，或者加锁操作在 循环体内，会耗费性能，这时虚拟机会扩大加锁范围。
 *              4、轻量级锁（Lightweight Locking）：
 *                  轻量级锁是JDK 1.6之中加入的新型锁机制。它的作用是 在没有多线程竞争的前提下，减少传统的重量级锁 使用操作系统互斥量 产生的性能消耗。
 *                  HotSpot虚拟机的对象头（Object Header）分为两部分信息，第一部分用于存储 对象自身的运行时数据，这部分称为Mark Word。还有一部分存储 指向方法区 对象类型数据 的指针。
 *                  加锁：.... 如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。
 *                  解锁：解锁过程也是通过CAS操作来进行的。如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。
 *                  性能：没有锁竞争时，轻量级锁用 CAS操作 替代 互斥量 的开销，性能较优。有锁竞争时，除了互斥量开销，还有CAS操作开销，所以性能较差。但是，一般情况下，在整个同步周期内都是不存在竞争的”，这是一个经验数据。
 *              5、偏向锁（Biased Locking）       ：
 *                  偏向锁也是JDK1.6中引入的锁优化，它的目的是 消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。
 *                  如果说 轻量级锁是在 无竞争的情况下 使用 CAS操作去消除同步使用的互斥量，那 偏向锁 就是在无竞争的情况下 把整个同步都消除掉，连CAS操作都不做了。
 *
 *                  当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。当有另外一个线程去尝试获取这个锁时，偏向模式结束。
 *                  偏向锁可以提高带有同步但无竞争的程序性能，但并不一定总是对程序运行有利。如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数-XX：-UseBiasedLocking来禁止偏向锁优化反而可以提升性能。
 *
 *  《*》JVM内存结构、内存模型 、对象模型那些事
 *      一、JVM内存结构
 *          如上，做个总结，JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。
 *
 *      二、Java内存模型
 *          Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个 抽象 的概念。
 *          JSR-133: Java Memory Model and Thread Specification 中描述了，JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。
 *          那么，简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用 共享内存 进行通信，在通信过程中会存在一系列如原子性、可见性、有序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。
 *              JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。
 *          在JMM中，我们把多个线程间通信的共享内存称之为主内存，而在并发编程中多个线程都维护了一个自己的本地内存（这是个抽象概念），其中保存的数据是主内存中的数据拷贝。而JMM主要是控制本地内存和主内存之间的数据交互的。
 *
 *      三、Java对象模型
 *          Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。
 *          HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。
 *          每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。
 *
 *      四、总结：
 *          我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。
 *              ~JVM内存结构，和Java虚拟机的运行时区域有关。
 *              ~Java内存模型，和Java的并发编程有关。
 *              ~Java对象模型，和Java对象在虚拟机中的表现形式有关。
 *
 *
 * 《*》锁优化 之 偏向锁、轻量级锁、重量级锁 -
 *      背景 - 我听说人类写的代码中有些特殊的地方，叫做 临界区，比如synchronized修饰的 方法 或者 代码块，他们非常神奇，在同一时刻JVM老大只允许一个线程进入执行。
 *          - 每次设置锁我都得和操作系统打交道，请他在内核中维护一个什么Mutex（互斥量）的东西，他还得把你们这些线程阻塞，切换，这可是一笔巨大的费用啊，所以这些锁还是少用为妙。
 *          - 仔细一想，老大煞费心机地设置了 偏向锁和轻量级锁，就是为了避免阻塞，避免操作系统的介入。
 *      1、偏向锁 - 通常只有一个线程在临界区执行。
 *
 *      2、轻量级锁 - 可以有多个线程交替进入临界区，在 竞争不激烈 的时候，稍微自旋等待一下就能获得锁。
 *
 *      3、重量级锁 - 也是我最为期待的锁，那就是出现了激烈的竞争，只好让我们去 阻塞 休息了。
 *
 *
 */
public class JVMLearn {

}
