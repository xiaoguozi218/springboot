package com.example.concurrent.jvm;

/**
 * Created by MintQ on 2018/6/28.
 *
 *  深入浅出JVM的锁优化案例
 *
 *  《*》锁优化 ：1、适应性自旋（Adaptive Spinning）： 线程阻塞的时候，让等待的线程不放弃cpu执行时间，而是执行一个自旋(一般是空循环)，这叫做自旋锁。
 *                  自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果 锁被占用的时间很短，自旋等待的效果就非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，带来性能上的浪费。
 *                  因此，自旋等待的时间必须要有 一定的限度。如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是 10 次，用户可以使用参数-XX：PreBlockSpin来更改。
 *                  JDK1.6引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。比如前一次自旋了3次就获得了一个锁，那么下一次虚拟机会允许他自旋更多次来获得这个锁。如果一个锁很少能通过自旋成功获得，那么之后再遇到这个情况就会省略自旋过程了。
 *              2、锁消除（Lock Elimination）    ：
 *                  虚拟机 即时编译器 在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。一般根据 逃逸分析 的数据支持来作为判定依据。
 *              3、锁粗化（Lock Coarsening）     ：
 *                  原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。
 *                  但如果一系列操作频繁对同一个对象加锁解锁，或者加锁操作在 循环体内，会耗费性能，这时虚拟机会扩大加锁范围。
 *              4、轻量级锁（Lightweight Locking）：
 *                  轻量级锁是JDK 1.6之中加入的新型锁机制。它的作用是 在没有多线程竞争的前提下，减少传统的重量级锁 使用操作系统互斥量 产生的性能消耗。
 *                  HotSpot虚拟机的对象头（Object Header）分为两部分信息，第一部分用于存储 对象自身的运行时数据，这部分称为Mark Word。还有一部分存储 指向方法区 对象类型数据 的指针。
 *                  加锁：.... 如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。
 *                  解锁：解锁过程也是通过CAS操作来进行的。如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。
 *                  性能：没有锁竞争时，轻量级锁用 CAS操作 替代 互斥量 的开销，性能较优。有锁竞争时，除了互斥量开销，还有CAS操作开销，所以性能较差。但是，一般情况下，在整个同步周期内都是不存在竞争的”，这是一个经验数据。
 *              5、偏向锁（Biased Locking）       ：
 *                  偏向锁也是JDK1.6中引入的锁优化，它的目的是 消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。
 *                  如果说 轻量级锁是在 无竞争的情况下 使用 CAS操作去消除同步使用的互斥量，那 偏向锁 就是在无竞争的情况下 把整个同步都消除掉，连CAS操作都不做了。
 *
 *                  当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。当有另外一个线程去尝试获取这个锁时，偏向模式结束。
 *                  偏向锁可以提高带有同步但无竞争的程序性能，但并不一定总是对程序运行有利。如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数-XX：-UseBiasedLocking来禁止偏向锁优化反而可以提升性能。
 *
 *  《*》
 *
 */
public class JVMLearn {

}
